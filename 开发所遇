2017.07.06
之前在学校没有放假的时候，对系统进行短时间内大量提交，发现很多程序运行起来算的时间都T了，在多个请求下，System.currentMillion...的这个方法跪了，所以最近两天采用获取CPU中用户态的时间作为程序的运行时间花费，但是遇到了对于实际上确实超时的程序无法判断，最近两天在解决这个问题，解决方法①：使用代理模式，对用户上交的Main类进行代理，然后在Main1中进行时间计算。该解决方案不能限制进程的运行时间；解决方法②：还是使用代理模式，但是在代理类的Around增强中，开一个子线程去执行用户上传的Main类，然后用do...while限制子线程的执行时间，这样既可以获得子线程的CPU运行时间，也可以限制子线程在CPU中的运行时间。出现的问题为，进程的标准输入流在运行时被关闭。解决方法③：针对上面的问题，在调试的过程中发现对于输入很长的用例，在输入一半时使用flush方法会抛出异常，猜想进程会限时关闭标准输入流？（感觉不是这个原因，但是异常栈中最后的方法为native方法，无法调试）然后尝试使用len=InputStream.read(byte[])代替len=InputStream.read()，使用OutputStream.write(bytes[],int,int)代替OutputStream.write(byte)
同时也遇到了一个问题，排序一个1000+以上的数，这时候用原来的代码来解决的话会一直阻塞，后来想到了对子进程的errorStream的处理，就在单元测试中对子进程在控制台输出的输出流作了同样的处理，而不是在主线程中对子进程的输出流作处理，并且outputStream每一次write()都需要flush()，防止缓冲区变满的情况，之前都能成功都是因为输出内容太少。
2017.07.18
解决了c程序的计时问题，但是在线下计时，对于一个n为1700+的快排计时为50ms左右，在服务器运行提交上来的程序则变成0。需要在日后编写一个时间复杂度比较高的程序再测试一下。
遇到问题：网站的设计，到底需不需要删除之前的提交记录（当前情况为删除，因为查询的时候可能会导致查询上一次的提交结果而不是当前提交的结果），不想进行删除，因为这样会导致数据库state表、submit表增删频繁，而且不是使用主键删除，可能会造成锁表的情况。如果不删除之前的提交记录，应该想一个办法去解决新一次提交却查到的是上一次查询结果的问题。